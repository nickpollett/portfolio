{"ast":null,"code":"import _objectSpread from \"C:/Users/Nicholas Pollett/Documents/GitHub/CollisionCalculator/calculator-website/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nconst DEFAULT_STYLE = {\n  version: 8,\n  sources: {},\n  layers: []\n};\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nconst handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox {\n  constructor(MapClass, props, container) {\n    // mapboxgl.Map instance\n    this._map = null;\n    // Internal states\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n    this._onEvent = e => {\n      // @ts-ignore\n      const cb = this.props[otherEvents[e.type]];\n      if (cb) {\n        cb(e);\n      } else if (e.type === 'error') {\n        console.error(e.error); // eslint-disable-line\n      }\n    };\n    this._onPointerEvent = e => {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        this._updateHover(e);\n      }\n      // @ts-ignore\n      const cb = this.props[pointerEvents[e.type]];\n      if (cb) {\n        if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n        }\n        cb(e);\n        delete e.features;\n      }\n    };\n    this._onCameraEvent = e => {\n      if (!this._internalUpdate) {\n        // @ts-ignore\n        const cb = this.props[cameraEvents[e.type]];\n        if (cb) {\n          cb(e);\n        }\n      }\n      if (e.type in this._deferredEvents) {\n        this._deferredEvents[e.type] = false;\n      }\n    };\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n  get map() {\n    return this._map;\n  }\n  get transform() {\n    return this._renderTransform;\n  }\n  setProps(props) {\n    const oldProps = this.props;\n    this.props = props;\n    const settingsChanged = this._updateSettings(props, oldProps);\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props, true);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props, oldProps);\n    this._updateHandlers(props, oldProps);\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n      this.redraw();\n    }\n  }\n  static reuse(props, container) {\n    const that = Mapbox.savedMaps.pop();\n    if (!that) {\n      return null;\n    }\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n    // Step 4: apply new props\n    that.setProps(_objectSpread(_objectSpread({}, props), {}, {\n      styleDiffing: false\n    }));\n    map.resize();\n    const {\n      initialViewState\n    } = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, _objectSpread(_objectSpread({}, initialViewState.fitBoundsOptions), {}, {\n          duration: 0\n        }));\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    }\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n  /* eslint-disable complexity,max-statements */\n  _initialize(container) {\n    const {\n      props\n    } = this;\n    const {\n      mapStyle = DEFAULT_STYLE\n    } = props;\n    const mapOptions = _objectSpread(_objectSpread(_objectSpread({}, props), props.initialViewState), {}, {\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(mapStyle)\n    });\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n    const map = new this._MapClass(mapOptions);\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    this._createShadowTransform(map);\n    // Hack\n    // Insert code into map's render cycle\n    const renderMap = map._render;\n    map._render = arg => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n    map._renderTaskQueue.run = arg => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n      this._onBeforeRepaint();\n    };\n    map.on('render', () => this._onAfterRepaint());\n    // Insert code into map's event pipeline\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent);\n    // add listeners\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children === null || children === void 0 ? void 0 : children.remove();\n    Mapbox.savedMaps.push(this);\n  }\n  destroy() {\n    this._map.remove();\n  }\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n  _createShadowTransform(map) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n    this._renderTransform = renderTransform;\n  }\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps) {\n    // Check if size is controlled\n    const {\n      viewState\n    } = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps, triggerEvents) {\n    if (this._internalUpdate) {\n      return false;\n    }\n    const map = this._map;\n    const tr = this._renderTransform;\n    // Take a snapshot of the transform before mutation\n    const {\n      zoom,\n      pitch,\n      bearing\n    } = tr;\n    const isMoving = map.isMoving();\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n    const changed = applyViewStateToTransform(tr, _objectSpread(_objectSpread({}, transformToViewState(map.transform)), nextProps));\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents;\n      // Delay DOM control updates to the next render cycle\n      deferredEvents.move = true;\n      deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n      deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n      deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n    }\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n    return changed;\n  }\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        const setter = map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))];\n        setter === null || setter === void 0 ? void 0 : setter(nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n  _updateStyle(nextProps, currProps) {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const {\n        mapStyle = DEFAULT_STYLE,\n        styleDiffing = true\n      } = nextProps;\n      const options = {\n        diff: styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        // @ts-ignore Mapbox specific prop\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(mapStyle), options);\n      return true;\n    }\n    return false;\n  }\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateStyleComponents(nextProps, currProps) {\n    const map = this._map;\n    let changed = false;\n    if (map.isStyleLoaded()) {\n      if ('light' in nextProps && map.setLight && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n      if ('fog' in nextProps && map.setFog && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n      if ('terrain' in nextProps && map.setTerrain && !deepEqual(nextProps.terrain, currProps.terrain)) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n    return changed;\n  }\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateHandlers(nextProps, currProps) {\n    var _a, _b;\n    const map = this._map;\n    let changed = false;\n    for (const propName of handlerNames) {\n      const newValue = (_a = nextProps[propName]) !== null && _a !== void 0 ? _a : true;\n      const oldValue = (_b = currProps[propName]) !== null && _b !== void 0 ? _b : true;\n      if (!deepEqual(newValue, oldValue)) {\n        changed = true;\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n    return changed;\n  }\n  _queryRenderedFeatures(point) {\n    const map = this._map;\n    const {\n      interactiveLayerIds = []\n    } = this.props;\n    try {\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch (_a) {\n      // May fail if style is not loaded\n      return [];\n    }\n  }\n  _updateHover(e) {\n    var _a;\n    const {\n      props\n    } = this;\n    const shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n  _fireEvent(baseFire, event, properties) {\n    const map = this._map;\n    const tr = map.transform;\n    const eventType = typeof event === 'string' ? event : event.type;\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        event.viewState = transformToViewState(tr);\n      }\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n        return map;\n      }\n    }\n    baseFire.call(map, event, properties);\n    return map;\n  }\n  // All camera manipulations are complete, ready to repaint\n  _onBeforeRepaint() {\n    const map = this._map;\n    // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n    this._internalUpdate = true;\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n    this._internalUpdate = false;\n    const tr = this._map.transform;\n    // Make sure camera matches the current props\n    this._map.transform = this._renderTransform;\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n}\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv() {\n  let accessToken = null;\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {\n    // ignore\n  }\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {\n    // ignore\n  }\n  return accessToken;\n}","map":{"version":3,"names":["transformToViewState","applyViewStateToTransform","cloneTransform","normalizeStyle","deepEqual","DEFAULT_STYLE","version","sources","layers","pointerEvents","mousedown","mouseup","mouseover","mousemove","click","dblclick","mouseenter","mouseleave","mouseout","contextmenu","touchstart","touchend","touchmove","touchcancel","cameraEvents","movestart","move","moveend","dragstart","drag","dragend","zoomstart","zoom","zoomend","rotatestart","rotate","rotateend","pitchstart","pitch","pitchend","otherEvents","wheel","boxzoomstart","boxzoomend","boxzoomcancel","resize","load","render","idle","remove","data","styledata","sourcedata","error","settingNames","handlerNames","Mapbox","constructor","MapClass","props","container","_map","_internalUpdate","_inRender","_hoveredFeatures","_deferredEvents","_onEvent","e","cb","type","console","_onPointerEvent","_updateHover","interactiveLayerIds","features","_queryRenderedFeatures","point","_onCameraEvent","_MapClass","_initialize","map","transform","_renderTransform","setProps","oldProps","settingsChanged","_updateSettings","_createShadowTransform","sizeChanged","_updateSize","viewStateChanged","_updateViewState","_updateStyle","_updateStyleComponents","_updateHandlers","isMoving","redraw","reuse","that","savedMaps","pop","oldContainer","getContainer","className","childNodes","length","appendChild","_container","resizeObserver","_resizeObserver","disconnect","observe","_objectSpread","styleDiffing","initialViewState","bounds","fitBounds","fitBoundsOptions","duration","isStyleLoaded","fire","once","_update","mapStyle","mapOptions","accessToken","mapboxAccessToken","getAccessTokenFromEnv","style","viewState","Object","assign","center","longitude","latitude","bearing","gl","getContext","HTMLCanvasElement","prototype","padding","setPadding","cursor","getCanvas","renderMap","_render","arg","call","runRenderTaskQueue","_renderTaskQueue","run","_onBeforeRepaint","on","_onAfterRepaint","fireEvent","_fireEvent","bind","width","height","eventName","recycle","children","querySelector","push","destroy","_frame","cancel","renderTransform","painter","nextProps","triggerEvents","tr","cameraElevationReference","changed","deferredEvents","currProps","propName","setter","concat","toUpperCase","slice","options","diff","localIdeographFontFamily","setStyle","setLight","light","setFog","fog","setTerrain","terrain","getSource","source","newValue","_a","oldValue","_b","enable","disable","queryRenderedFeatures","filter","getLayer","shouldTrackHoveredFeatures","onMouseMove","onMouseEnter","onMouseLeave","eventType","wasHovering","isHovering","baseFire","event","properties","location","match","exec","search","process","env","MapboxAccessToken","REACT_APP_MAPBOX_ACCESS_TOKEN"],"sources":["C:\\Users\\Nicholas Pollett\\Documents\\GitHub\\CollisionCalculator\\calculator-website\\node_modules\\react-map-gl\\src\\mapbox\\mapbox.ts"],"sourcesContent":["import {transformToViewState, applyViewStateToTransform, cloneTransform} from '../utils/transform';\nimport {normalizeStyle} from '../utils/style-utils';\nimport {deepEqual} from '../utils/deep-equal';\n\nimport type {\n  Transform,\n  ViewState,\n  ViewStateChangeEvent,\n  Point,\n  PointLike,\n  PaddingOptions,\n  Light,\n  Fog,\n  Terrain,\n  MapboxStyle,\n  ImmutableLike,\n  LngLatBoundsLike,\n  MapMouseEvent,\n  MapLayerMouseEvent,\n  MapLayerTouchEvent,\n  MapWheelEvent,\n  MapBoxZoomEvent,\n  MapStyleDataEvent,\n  MapSourceDataEvent,\n  MapEvent,\n  ErrorEvent,\n  MapGeoJSONFeature,\n  MapInstance,\n  MapInstanceInternal\n} from '../types';\n\nexport type MapboxProps<MapT extends MapInstance = MapInstance> = Partial<ViewState> & {\n  // Init options\n  mapboxAccessToken?: string;\n\n  /** Camera options used when constructing the Map instance */\n  initialViewState?: Partial<ViewState> & {\n    /** The initial bounds of the map. If bounds is specified, it overrides longitude, latitude and zoom options. */\n    bounds?: LngLatBoundsLike;\n    /** A fitBounds options object to use only when setting the bounds option. */\n    fitBoundsOptions?: {\n      offset?: PointLike;\n      minZoom?: number;\n      maxZoom?: number;\n      padding?: number | PaddingOptions;\n    };\n  };\n\n  /** If provided, render into an external WebGL context */\n  gl?: WebGLRenderingContext;\n\n  /** For external controller to override the camera state */\n  viewState?: ViewState & {\n    width: number;\n    height: number;\n  };\n\n  // Styling\n\n  /** Mapbox style */\n  mapStyle?: string | MapboxStyle | ImmutableLike<MapboxStyle>;\n  /** Enable diffing when the map style changes\n   * @default true\n   */\n  styleDiffing?: boolean;\n  /** The fog property of the style. Must conform to the Fog Style Specification .\n   * If `undefined` is provided, removes the fog from the map. */\n  fog?: Fog;\n  /** Light properties of the map. */\n  light?: Light;\n  /** Terrain property of the style. Must conform to the Terrain Style Specification .\n   * If `undefined` is provided, removes terrain from the map. */\n  terrain?: Terrain;\n\n  /** Default layers to query on pointer events */\n  interactiveLayerIds?: string[];\n  /** CSS cursor */\n  cursor?: string;\n\n  // Callbacks\n  onMouseDown?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseUp?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseOver?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseMove?: (e: MapLayerMouseEvent<MapT>) => void;\n  onClick?: (e: MapLayerMouseEvent<MapT>) => void;\n  onDblClick?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseEnter?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseLeave?: (e: MapLayerMouseEvent<MapT>) => void;\n  onMouseOut?: (e: MapLayerMouseEvent<MapT>) => void;\n  onContextMenu?: (e: MapLayerMouseEvent<MapT>) => void;\n  onTouchStart?: (e: MapLayerTouchEvent<MapT>) => void;\n  onTouchEnd?: (e: MapLayerTouchEvent<MapT>) => void;\n  onTouchMove?: (e: MapLayerTouchEvent<MapT>) => void;\n  onTouchCancel?: (e: MapLayerTouchEvent<MapT>) => void;\n\n  onMoveStart?: (e: ViewStateChangeEvent<MapT>) => void;\n  onMove?: (e: ViewStateChangeEvent<MapT>) => void;\n  onMoveEnd?: (e: ViewStateChangeEvent<MapT>) => void;\n  onDragStart?: (e: ViewStateChangeEvent<MapT>) => void;\n  onDrag?: (e: ViewStateChangeEvent<MapT>) => void;\n  onDragEnd?: (e: ViewStateChangeEvent<MapT>) => void;\n  onZoomStart?: (e: ViewStateChangeEvent<MapT>) => void;\n  onZoom?: (e: ViewStateChangeEvent<MapT>) => void;\n  onZoomEnd?: (e: ViewStateChangeEvent<MapT>) => void;\n  onRotateStart?: (e: ViewStateChangeEvent<MapT>) => void;\n  onRotate?: (e: ViewStateChangeEvent<MapT>) => void;\n  onRotateEnd?: (e: ViewStateChangeEvent<MapT>) => void;\n  onPitchStart?: (e: ViewStateChangeEvent<MapT>) => void;\n  onPitch?: (e: ViewStateChangeEvent<MapT>) => void;\n  onPitchEnd?: (e: ViewStateChangeEvent<MapT>) => void;\n\n  onWheel?: (e: MapWheelEvent<MapT>) => void;\n  onBoxZoomStart?: (e: MapBoxZoomEvent<MapT>) => void;\n  onBoxZoomEnd?: (e: MapBoxZoomEvent<MapT>) => void;\n  onBoxZoomCancel?: (e: MapBoxZoomEvent<MapT>) => void;\n\n  onResize?: (e: MapEvent<MapT>) => void;\n  onLoad?: (e: MapEvent<MapT>) => void;\n  onRender?: (e: MapEvent<MapT>) => void;\n  onIdle?: (e: MapEvent<MapT>) => void;\n  onError?: (e: ErrorEvent<MapT>) => void;\n  onRemove?: (e: MapEvent<MapT>) => void;\n  onData?: (e: MapStyleDataEvent<MapT> | MapSourceDataEvent<MapT>) => void;\n  onStyleData?: (e: MapStyleDataEvent<MapT>) => void;\n  onSourceData?: (e: MapSourceDataEvent<MapT>) => void;\n};\n\nconst DEFAULT_STYLE = {version: 8, sources: {}, layers: []} as MapboxStyle;\n\nconst pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nconst cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nconst otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nconst settingNames = [\n  'minZoom',\n  'maxZoom',\n  'minPitch',\n  'maxPitch',\n  'maxBounds',\n  'projection',\n  'renderWorldCopies'\n];\nconst handlerNames = [\n  'scrollZoom',\n  'boxZoom',\n  'dragRotate',\n  'dragPan',\n  'keyboard',\n  'doubleClickZoom',\n  'touchZoomRotate',\n  'touchPitch'\n];\n\n/**\n * A wrapper for mapbox-gl's Map class\n */\nexport default class Mapbox<MapT extends MapInstance = MapInstance> {\n  private _MapClass: {new (options: any): MapInstance};\n  // mapboxgl.Map instance\n  private _map: MapInstanceInternal<MapT> = null;\n  // User-supplied props\n  props: MapboxProps<MapT>;\n\n  // Mapbox map is stateful.\n  // During method calls/user interactions, map.transform is mutated and\n  // deviate from user-supplied props.\n  // In order to control the map reactively, we shadow the transform\n  // with the one below, which reflects the view state resolved from\n  // both user-supplied props and the underlying state\n  private _renderTransform: Transform;\n\n  // Internal states\n  private _internalUpdate: boolean = false;\n  private _inRender: boolean = false;\n  private _hoveredFeatures: MapGeoJSONFeature[] = null;\n  private _deferredEvents: {\n    move: boolean;\n    zoom: boolean;\n    pitch: boolean;\n    rotate: boolean;\n  } = {\n    move: false,\n    zoom: false,\n    pitch: false,\n    rotate: false\n  };\n\n  static savedMaps: Mapbox[] = [];\n\n  constructor(\n    MapClass: {new (options: any): MapInstance},\n    props: MapboxProps<MapT>,\n    container: HTMLDivElement\n  ) {\n    this._MapClass = MapClass;\n    this.props = props;\n    this._initialize(container);\n  }\n\n  get map(): MapT {\n    return this._map;\n  }\n\n  get transform(): Transform {\n    return this._renderTransform;\n  }\n\n  setProps(props: MapboxProps<MapT>) {\n    const oldProps = this.props;\n    this.props = props;\n\n    const settingsChanged = this._updateSettings(props, oldProps);\n    if (settingsChanged) {\n      this._createShadowTransform(this._map);\n    }\n    const sizeChanged = this._updateSize(props);\n    const viewStateChanged = this._updateViewState(props, true);\n    this._updateStyle(props, oldProps);\n    this._updateStyleComponents(props, oldProps);\n    this._updateHandlers(props, oldProps);\n\n    // If 1) view state has changed to match props and\n    //    2) the props change is not triggered by map events,\n    // it's driven by an external state change. Redraw immediately\n    if (settingsChanged || sizeChanged || (viewStateChanged && !this._map.isMoving())) {\n      this.redraw();\n    }\n  }\n\n  static reuse<MapT extends MapInstance>(\n    props: MapboxProps<MapT>,\n    container: HTMLDivElement\n  ): Mapbox<MapT> {\n    const that = Mapbox.savedMaps.pop() as Mapbox<MapT>;\n    if (!that) {\n      return null;\n    }\n\n    const map = that.map;\n    // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n    // intoto the new container from the props.\n    // Step 1: reparenting child nodes from old container to new container\n    const oldContainer = map.getContainer();\n    container.className = oldContainer.className;\n    while (oldContainer.childNodes.length > 0) {\n      container.appendChild(oldContainer.childNodes[0]);\n    }\n    // Step 2: replace the internal container with new container from the react component\n    // @ts-ignore\n    map._container = container;\n\n    // With maplibre-gl as mapLib, map uses ResizeObserver to observe when its container resizes.\n    // When reusing the saved map, we need to disconnect the observer and observe the new container.\n    // Step 3: telling the ResizeObserver to disconnect and observe the new container\n    // @ts-ignore\n    const resizeObserver = map._resizeObserver;\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n      resizeObserver.observe(container);\n    }\n\n    // Step 4: apply new props\n    that.setProps({...props, styleDiffing: false});\n    map.resize();\n    const {initialViewState} = props;\n    if (initialViewState) {\n      if (initialViewState.bounds) {\n        map.fitBounds(initialViewState.bounds, {...initialViewState.fitBoundsOptions, duration: 0});\n      } else {\n        that._updateViewState(initialViewState, false);\n      }\n    }\n\n    // Simulate load event\n    if (map.isStyleLoaded()) {\n      map.fire('load');\n    } else {\n      map.once('styledata', () => map.fire('load'));\n    }\n\n    // Force reload\n    // @ts-ignore\n    map._update();\n    return that;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _initialize(container: HTMLDivElement) {\n    const {props} = this;\n    const {mapStyle = DEFAULT_STYLE} = props;\n    const mapOptions = {\n      ...props,\n      ...props.initialViewState,\n      accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n      container,\n      style: normalizeStyle(mapStyle)\n    };\n\n    const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n    Object.assign(mapOptions, {\n      center: [viewState.longitude || 0, viewState.latitude || 0],\n      zoom: viewState.zoom || 0,\n      pitch: viewState.pitch || 0,\n      bearing: viewState.bearing || 0\n    });\n\n    if (props.gl) {\n      // eslint-disable-next-line\n      const getContext = HTMLCanvasElement.prototype.getContext;\n      // Hijack canvas.getContext to return our own WebGLContext\n      // This will be called inside the mapboxgl.Map constructor\n      // @ts-expect-error\n      HTMLCanvasElement.prototype.getContext = () => {\n        // Unhijack immediately\n        HTMLCanvasElement.prototype.getContext = getContext;\n        return props.gl;\n      };\n    }\n\n    const map = new this._MapClass(mapOptions) as MapInstanceInternal<MapT>;\n    // Props that are not part of constructor options\n    if (viewState.padding) {\n      map.setPadding(viewState.padding);\n    }\n    if (props.cursor) {\n      map.getCanvas().style.cursor = props.cursor;\n    }\n    this._createShadowTransform(map);\n\n    // Hack\n    // Insert code into map's render cycle\n    const renderMap = map._render;\n    map._render = (arg: number) => {\n      this._inRender = true;\n      renderMap.call(map, arg);\n      this._inRender = false;\n    };\n    const runRenderTaskQueue = map._renderTaskQueue.run;\n    map._renderTaskQueue.run = (arg: number) => {\n      runRenderTaskQueue.call(map._renderTaskQueue, arg);\n      this._onBeforeRepaint();\n    };\n    map.on('render', () => this._onAfterRepaint());\n    // Insert code into map's event pipeline\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const fireEvent = map.fire;\n    map.fire = this._fireEvent.bind(this, fireEvent);\n\n    // add listeners\n    map.on('resize', () => {\n      this._renderTransform.resize(map.transform.width, map.transform.height);\n    });\n    map.on('styledata', () => this._updateStyleComponents(this.props, {}));\n    map.on('sourcedata', () => this._updateStyleComponents(this.props, {}));\n    for (const eventName in pointerEvents) {\n      map.on(eventName, this._onPointerEvent);\n    }\n    for (const eventName in cameraEvents) {\n      map.on(eventName, this._onCameraEvent);\n    }\n    for (const eventName in otherEvents) {\n      map.on(eventName, this._onEvent);\n    }\n    this._map = map;\n  }\n  /* eslint-enable complexity,max-statements */\n\n  recycle() {\n    // Clean up unnecessary elements before storing for reuse.\n    const container = this.map.getContainer();\n    const children = container.querySelector('[mapboxgl-children]');\n    children?.remove();\n\n    Mapbox.savedMaps.push(this);\n  }\n\n  destroy() {\n    this._map.remove();\n  }\n\n  // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n  // render cycle, which is managed by Mapbox's animation loop.\n  // This removes the synchronization issue caused by requestAnimationFrame.\n  redraw() {\n    const map = this._map as any;\n    // map._render will throw error if style does not exist\n    // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n    //   /src/ui/map.js#L1834\n    if (!this._inRender && map.style) {\n      // cancel the scheduled update\n      if (map._frame) {\n        map._frame.cancel();\n        map._frame = null;\n      }\n      // the order is important - render() may schedule another update\n      map._render();\n    }\n  }\n\n  _createShadowTransform(map: any) {\n    const renderTransform = cloneTransform(map.transform);\n    map.painter.transform = renderTransform;\n\n    this._renderTransform = renderTransform;\n  }\n\n  /* Trigger map resize if size is controlled\n     @param {object} nextProps\n     @returns {bool} true if size has changed\n   */\n  _updateSize(nextProps: MapboxProps<MapT>): boolean {\n    // Check if size is controlled\n    const {viewState} = nextProps;\n    if (viewState) {\n      const map = this._map;\n      if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n        map.resize();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Adapted from map.jumpTo\n  /* Update camera to match props\n     @param {object} nextProps\n     @param {bool} triggerEvents - should fire camera events\n     @returns {bool} true if anything is changed\n   */\n  _updateViewState(nextProps: MapboxProps<MapT>, triggerEvents: boolean): boolean {\n    if (this._internalUpdate) {\n      return false;\n    }\n    const map = this._map;\n\n    const tr = this._renderTransform;\n    // Take a snapshot of the transform before mutation\n    const {zoom, pitch, bearing} = tr;\n    const isMoving = map.isMoving();\n\n    if (isMoving) {\n      // All movement of the camera is done relative to the sea level\n      tr.cameraElevationReference = 'sea';\n    }\n    const changed = applyViewStateToTransform(tr, {\n      ...transformToViewState(map.transform),\n      ...nextProps\n    });\n    if (isMoving) {\n      // Reset camera reference\n      tr.cameraElevationReference = 'ground';\n    }\n\n    if (changed && triggerEvents) {\n      const deferredEvents = this._deferredEvents;\n      // Delay DOM control updates to the next render cycle\n      deferredEvents.move = true;\n      deferredEvents.zoom ||= zoom !== tr.zoom;\n      deferredEvents.rotate ||= bearing !== tr.bearing;\n      deferredEvents.pitch ||= pitch !== tr.pitch;\n    }\n\n    // Avoid manipulating the real transform when interaction/animation is ongoing\n    // as it would interfere with Mapbox's handlers\n    if (!isMoving) {\n      applyViewStateToTransform(map.transform, nextProps);\n    }\n\n    return changed;\n  }\n\n  /* Update camera constraints and projection settings to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateSettings(nextProps: MapboxProps<MapT>, currProps: MapboxProps<MapT>): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of settingNames) {\n      if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n        changed = true;\n        const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];\n        setter?.(nextProps[propName]);\n      }\n    }\n    return changed;\n  }\n\n  /* Update map style to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if style is changed\n   */\n  _updateStyle(nextProps: MapboxProps<MapT>, currProps: MapboxProps<MapT>): boolean {\n    if (nextProps.cursor !== currProps.cursor) {\n      this._map.getCanvas().style.cursor = nextProps.cursor;\n    }\n    if (nextProps.mapStyle !== currProps.mapStyle) {\n      const {mapStyle = DEFAULT_STYLE, styleDiffing = true} = nextProps;\n      const options: any = {\n        diff: styleDiffing\n      };\n      if ('localIdeographFontFamily' in nextProps) {\n        // @ts-ignore Mapbox specific prop\n        options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n      }\n      this._map.setStyle(normalizeStyle(mapStyle), options);\n      return true;\n    }\n    return false;\n  }\n\n  /* Update fog, light and terrain to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateStyleComponents(nextProps: MapboxProps<MapT>, currProps: MapboxProps<MapT>): boolean {\n    const map = this._map;\n    let changed = false;\n    if (map.isStyleLoaded()) {\n      if ('light' in nextProps && map.setLight && !deepEqual(nextProps.light, currProps.light)) {\n        changed = true;\n        map.setLight(nextProps.light);\n      }\n      if ('fog' in nextProps && map.setFog && !deepEqual(nextProps.fog, currProps.fog)) {\n        changed = true;\n        map.setFog(nextProps.fog);\n      }\n      if (\n        'terrain' in nextProps &&\n        map.setTerrain &&\n        !deepEqual(nextProps.terrain, currProps.terrain)\n      ) {\n        if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n          changed = true;\n          map.setTerrain(nextProps.terrain);\n        }\n      }\n    }\n    return changed;\n  }\n\n  /* Update interaction handlers to match props\n     @param {object} nextProps\n     @param {object} currProps\n     @returns {bool} true if anything is changed\n   */\n  _updateHandlers(nextProps: MapboxProps<MapT>, currProps: MapboxProps<MapT>): boolean {\n    const map = this._map;\n    let changed = false;\n    for (const propName of handlerNames) {\n      const newValue = nextProps[propName] ?? true;\n      const oldValue = currProps[propName] ?? true;\n      if (!deepEqual(newValue, oldValue)) {\n        changed = true;\n        if (newValue) {\n          map[propName].enable(newValue);\n        } else {\n          map[propName].disable();\n        }\n      }\n    }\n    return changed;\n  }\n\n  _onEvent = (e: MapEvent<MapT>) => {\n    // @ts-ignore\n    const cb = this.props[otherEvents[e.type]];\n    if (cb) {\n      cb(e);\n    } else if (e.type === 'error') {\n      console.error((e as ErrorEvent<MapT>).error); // eslint-disable-line\n    }\n  };\n\n  private _queryRenderedFeatures(point: Point) {\n    const map = this._map;\n    const {interactiveLayerIds = []} = this.props;\n    try {\n      return map.queryRenderedFeatures(point, {\n        layers: interactiveLayerIds.filter(map.getLayer.bind(map))\n      });\n    } catch {\n      // May fail if style is not loaded\n      return [];\n    }\n  }\n\n  _updateHover(e: MapMouseEvent<MapT>) {\n    const {props} = this;\n    const shouldTrackHoveredFeatures =\n      props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n    if (shouldTrackHoveredFeatures) {\n      const eventType = e.type;\n      const wasHovering = this._hoveredFeatures?.length > 0;\n      const features = this._queryRenderedFeatures(e.point);\n      const isHovering = features.length > 0;\n\n      if (!isHovering && wasHovering) {\n        e.type = 'mouseleave';\n        this._onPointerEvent(e);\n      }\n      this._hoveredFeatures = features;\n      if (isHovering && !wasHovering) {\n        e.type = 'mouseenter';\n        this._onPointerEvent(e);\n      }\n      e.type = eventType;\n    } else {\n      this._hoveredFeatures = null;\n    }\n  }\n\n  _onPointerEvent = (e: MapLayerMouseEvent<MapT> | MapLayerTouchEvent<MapT>) => {\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      this._updateHover(e);\n    }\n\n    // @ts-ignore\n    const cb = this.props[pointerEvents[e.type]];\n    if (cb) {\n      if (this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n        e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);\n      }\n      cb(e);\n      delete e.features;\n    }\n  };\n\n  _onCameraEvent = (e: ViewStateChangeEvent<MapT>) => {\n    if (!this._internalUpdate) {\n      // @ts-ignore\n      const cb = this.props[cameraEvents[e.type]];\n      if (cb) {\n        cb(e);\n      }\n    }\n    if (e.type in this._deferredEvents) {\n      this._deferredEvents[e.type] = false;\n    }\n  };\n\n  _fireEvent(baseFire: Function, event: string | MapEvent<MapT>, properties?: object) {\n    const map = this._map;\n    const tr = map.transform;\n\n    const eventType = typeof event === 'string' ? event : event.type;\n    if (eventType === 'move') {\n      this._updateViewState(this.props, false);\n    }\n    if (eventType in cameraEvents) {\n      if (typeof event === 'object') {\n        (event as unknown as ViewStateChangeEvent<MapT>).viewState = transformToViewState(tr);\n      }\n      if (this._map.isMoving()) {\n        // Replace map.transform with ours during the callbacks\n        map.transform = this._renderTransform;\n        baseFire.call(map, event, properties);\n        map.transform = tr;\n\n        return map;\n      }\n    }\n    baseFire.call(map, event, properties);\n\n    return map;\n  }\n\n  // All camera manipulations are complete, ready to repaint\n  _onBeforeRepaint() {\n    const map = this._map;\n\n    // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n    this._internalUpdate = true;\n    for (const eventType in this._deferredEvents) {\n      if (this._deferredEvents[eventType]) {\n        map.fire(eventType);\n      }\n    }\n    this._internalUpdate = false;\n\n    const tr = this._map.transform;\n    // Make sure camera matches the current props\n    this._map.transform = this._renderTransform;\n\n    this._onAfterRepaint = () => {\n      // Restores camera state before render/load events are fired\n      this._map.transform = tr;\n    };\n  }\n\n  _onAfterRepaint: () => void;\n}\n\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\nfunction getAccessTokenFromEnv(): string {\n  let accessToken = null;\n\n  /* global location, process */\n  if (typeof location !== 'undefined') {\n    const match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  }\n\n  // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch {\n    // ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch {\n    // ignore\n  }\n\n  return accessToken;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}