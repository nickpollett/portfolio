{"ast":null,"code":"import _defineProperty from \"C:/Users/Nicholas Pollett/Documents/GitHub/CollisionCalculator/calculator-website/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// src/index.ts\nvar SplayTreeNode = class SplayTreeNode {\n  constructor(key) {\n    _defineProperty(this, \"key\", void 0);\n    _defineProperty(this, \"left\", null);\n    _defineProperty(this, \"right\", null);\n    this.key = key;\n  }\n};\nvar SplayTreeSetNode = class extends SplayTreeNode {\n  constructor(key) {\n    super(key);\n  }\n};\nvar SplayTreeMapNode = class _SplayTreeMapNode extends SplayTreeNode {\n  constructor(key, value) {\n    super(key);\n    _defineProperty(this, \"value\", void 0);\n    this.value = value;\n  }\n  replaceValue(value) {\n    const node = new _SplayTreeMapNode(this.key, value);\n    node.left = this.left;\n    node.right = this.right;\n    return node;\n  }\n};\nvar SplayTree = class SplayTree {\n  constructor() {\n    _defineProperty(this, \"size\", 0);\n    _defineProperty(this, \"modificationCount\", 0);\n    _defineProperty(this, \"splayCount\", 0);\n  }\n  splay(key) {\n    const root = this.root;\n    if (root == null) {\n      this.compare(key, key);\n      return -1;\n    }\n    let right = null;\n    let newTreeRight = null;\n    let left = null;\n    let newTreeLeft = null;\n    let current = root;\n    const compare = this.compare;\n    let comp;\n    while (true) {\n      comp = compare(current.key, key);\n      if (comp > 0) {\n        let currentLeft = current.left;\n        if (currentLeft == null) break;\n        comp = compare(currentLeft.key, key);\n        if (comp > 0) {\n          current.left = currentLeft.right;\n          currentLeft.right = current;\n          current = currentLeft;\n          currentLeft = current.left;\n          if (currentLeft == null) break;\n        }\n        if (right == null) {\n          newTreeRight = current;\n        } else {\n          right.left = current;\n        }\n        right = current;\n        current = currentLeft;\n      } else if (comp < 0) {\n        let currentRight = current.right;\n        if (currentRight == null) break;\n        comp = compare(currentRight.key, key);\n        if (comp < 0) {\n          current.right = currentRight.left;\n          currentRight.left = current;\n          current = currentRight;\n          currentRight = current.right;\n          if (currentRight == null) break;\n        }\n        if (left == null) {\n          newTreeLeft = current;\n        } else {\n          left.right = current;\n        }\n        left = current;\n        current = currentRight;\n      } else {\n        break;\n      }\n    }\n    if (left != null) {\n      left.right = current.left;\n      current.left = newTreeLeft;\n    }\n    if (right != null) {\n      right.left = current.right;\n      current.right = newTreeRight;\n    }\n    if (this.root !== current) {\n      this.root = current;\n      this.splayCount++;\n    }\n    return comp;\n  }\n  splayMin(node) {\n    let current = node;\n    let nextLeft = current.left;\n    while (nextLeft != null) {\n      const left = nextLeft;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n      nextLeft = current.left;\n    }\n    return current;\n  }\n  splayMax(node) {\n    let current = node;\n    let nextRight = current.right;\n    while (nextRight != null) {\n      const right = nextRight;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n      nextRight = current.right;\n    }\n    return current;\n  }\n  _delete(key) {\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp != 0) return null;\n    let root = this.root;\n    const result = root;\n    const left = root.left;\n    this.size--;\n    if (left == null) {\n      this.root = root.right;\n    } else {\n      const right = root.right;\n      root = this.splayMax(left);\n      root.right = right;\n      this.root = root;\n    }\n    this.modificationCount++;\n    return result;\n  }\n  addNewRoot(node, comp) {\n    this.size++;\n    this.modificationCount++;\n    const root = this.root;\n    if (root == null) {\n      this.root = node;\n      return;\n    }\n    if (comp < 0) {\n      node.left = root;\n      node.right = root.right;\n      root.right = null;\n    } else {\n      node.right = root;\n      node.left = root.left;\n      root.left = null;\n    }\n    this.root = node;\n  }\n  _first() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMin(root);\n    return this.root;\n  }\n  _last() {\n    const root = this.root;\n    if (root == null) return null;\n    this.root = this.splayMax(root);\n    return this.root;\n  }\n  clear() {\n    this.root = null;\n    this.size = 0;\n    this.modificationCount++;\n  }\n  has(key) {\n    return this.validKey(key) && this.splay(key) == 0;\n  }\n  defaultCompare() {\n    return (a, b) => a < b ? -1 : a > b ? 1 : 0;\n  }\n  wrap() {\n    return {\n      getRoot: () => {\n        return this.root;\n      },\n      setRoot: root => {\n        this.root = root;\n      },\n      getSize: () => {\n        return this.size;\n      },\n      getModificationCount: () => {\n        return this.modificationCount;\n      },\n      getSplayCount: () => {\n        return this.splayCount;\n      },\n      setSplayCount: count => {\n        this.splayCount = count;\n      },\n      splay: key => {\n        return this.splay(key);\n      },\n      has: key => {\n        return this.has(key);\n      }\n    };\n  }\n};\nvar SplayTreeMap = class SplayTreeMap extends SplayTree {\n  constructor(compare, isValidKey) {\n    super();\n    _defineProperty(this, \"root\", null);\n    _defineProperty(this, \"compare\", void 0);\n    _defineProperty(this, \"validKey\", void 0);\n    _defineProperty(this, Symbol.toStringTag, \"[object Map]\");\n    this.compare = compare !== null && compare !== void 0 ? compare : this.defaultCompare();\n    this.validKey = isValidKey !== null && isValidKey !== void 0 ? isValidKey : a => a != null && a != void 0;\n  }\n  delete(key) {\n    if (!this.validKey(key)) return false;\n    return this._delete(key) != null;\n  }\n  forEach(f) {\n    const nodes = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value[1], result.value[0], this);\n    }\n  }\n  get(key) {\n    if (!this.validKey(key)) return void 0;\n    if (this.root != null) {\n      const comp = this.splay(key);\n      if (comp == 0) {\n        return this.root.value;\n      }\n    }\n    return void 0;\n  }\n  hasValue(value) {\n    const initialSplayCount = this.splayCount;\n    const visit = node => {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != this.splayCount) {\n          throw \"Concurrent modification during iteration.\";\n        }\n        if (node.right != null && visit(node.right)) {\n          return true;\n        }\n        node = node.left;\n      }\n      return false;\n    };\n    return visit(this.root);\n  }\n  set(key, value) {\n    const comp = this.splay(key);\n    if (comp == 0) {\n      this.root = this.root.replaceValue(value);\n      this.splayCount += 1;\n      return this;\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return this;\n  }\n  setAll(other) {\n    other.forEach((value, key) => {\n      this.set(key, value);\n    });\n  }\n  setIfAbsent(key, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      return this.root.value;\n    }\n    const modificationCount = this.modificationCount;\n    const splayCount = this.splayCount;\n    const value = ifAbsent();\n    if (modificationCount != this.modificationCount) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (splayCount != this.splayCount) {\n      comp = this.splay(key);\n    }\n    this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return !this.isEmpty();\n  }\n  firstKey() {\n    if (this.root == null) return null;\n    return this._first().key;\n  }\n  lastKey() {\n    if (this.root == null) return null;\n    return this._last().key;\n  }\n  lastKeyBefore(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstKeyAfter(key) {\n    if (key == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(key);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  update(key, update, ifAbsent) {\n    let comp = this.splay(key);\n    if (comp == 0) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = update(this.root.value);\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        this.splay(key);\n      }\n      this.root = this.root.replaceValue(newValue);\n      this.splayCount += 1;\n      return newValue;\n    }\n    if (ifAbsent != null) {\n      const modificationCount = this.modificationCount;\n      const splayCount = this.splayCount;\n      const newValue = ifAbsent();\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (splayCount != this.splayCount) {\n        comp = this.splay(key);\n      }\n      this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n      return newValue;\n    }\n    throw \"Invalid argument (key): Key not in map.\";\n  }\n  updateAll(update) {\n    const root = this.root;\n    if (root == null) return;\n    const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n    let node;\n    while (node = iterator.next(), !node.done) {\n      const newValue = update(...node.value);\n      iterator.replaceValue(newValue);\n    }\n  }\n  keys() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n  values() {\n    return new SplayTreeValueIterableIterator(this.wrap());\n  }\n  entries() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeMapEntryIterableIterator(this.wrap());\n  }\n};\nvar SplayTreeSet = class _SplayTreeSet extends SplayTree {\n  constructor(compare, isValidKey) {\n    super();\n    _defineProperty(this, \"root\", null);\n    _defineProperty(this, \"compare\", void 0);\n    _defineProperty(this, \"validKey\", void 0);\n    _defineProperty(this, Symbol.toStringTag, \"[object Set]\");\n    this.compare = compare !== null && compare !== void 0 ? compare : this.defaultCompare();\n    this.validKey = isValidKey !== null && isValidKey !== void 0 ? isValidKey : v => v != null && v != void 0;\n  }\n  delete(element) {\n    if (!this.validKey(element)) return false;\n    return this._delete(element) != null;\n  }\n  deleteAll(elements) {\n    for (const element of elements) {\n      this.delete(element);\n    }\n  }\n  forEach(f) {\n    const nodes = this[Symbol.iterator]();\n    let result;\n    while (result = nodes.next(), !result.done) {\n      f(result.value, result.value, this);\n    }\n  }\n  add(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this;\n  }\n  addAndReturn(element) {\n    const compare = this.splay(element);\n    if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n    return this.root.key;\n  }\n  addAll(elements) {\n    for (const element of elements) {\n      this.add(element);\n    }\n  }\n  isEmpty() {\n    return this.root == null;\n  }\n  isNotEmpty() {\n    return this.root != null;\n  }\n  single() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    if (this.size > 1) throw \"Bad state: Too many element\";\n    return this.root.key;\n  }\n  first() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._first().key;\n  }\n  last() {\n    if (this.size == 0) throw \"Bad state: No element\";\n    return this._last().key;\n  }\n  lastBefore(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp < 0) return this.root.key;\n    let node = this.root.left;\n    if (node == null) return null;\n    let nodeRight = node.right;\n    while (nodeRight != null) {\n      node = nodeRight;\n      nodeRight = node.right;\n    }\n    return node.key;\n  }\n  firstAfter(element) {\n    if (element == null) throw \"Invalid arguments(s)\";\n    if (this.root == null) return null;\n    const comp = this.splay(element);\n    if (comp > 0) return this.root.key;\n    let node = this.root.right;\n    if (node == null) return null;\n    let nodeLeft = node.left;\n    while (nodeLeft != null) {\n      node = nodeLeft;\n      nodeLeft = node.left;\n    }\n    return node.key;\n  }\n  retainAll(elements) {\n    const retainSet = new _SplayTreeSet(this.compare, this.validKey);\n    const modificationCount = this.modificationCount;\n    for (const object of elements) {\n      if (modificationCount != this.modificationCount) {\n        throw \"Concurrent modification during iteration.\";\n      }\n      if (this.validKey(object) && this.splay(object) == 0) {\n        retainSet.add(this.root.key);\n      }\n    }\n    if (retainSet.size != this.size) {\n      this.root = retainSet.root;\n      this.size = retainSet.size;\n      this.modificationCount++;\n    }\n  }\n  lookup(object) {\n    if (!this.validKey(object)) return null;\n    const comp = this.splay(object);\n    if (comp != 0) return null;\n    return this.root.key;\n  }\n  intersection(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  difference(other) {\n    const result = new _SplayTreeSet(this.compare, this.validKey);\n    for (const element of this) {\n      if (!other.has(element)) result.add(element);\n    }\n    return result;\n  }\n  union(other) {\n    const u = this.clone();\n    u.addAll(other);\n    return u;\n  }\n  clone() {\n    const set = new _SplayTreeSet(this.compare, this.validKey);\n    set.size = this.size;\n    set.root = this.copyNode(this.root);\n    return set;\n  }\n  copyNode(node) {\n    if (node == null) return null;\n    function copyChildren(node2, dest) {\n      let left;\n      let right;\n      do {\n        left = node2.left;\n        right = node2.right;\n        if (left != null) {\n          const newLeft = new SplayTreeSetNode(left.key);\n          dest.left = newLeft;\n          copyChildren(left, newLeft);\n        }\n        if (right != null) {\n          const newRight = new SplayTreeSetNode(right.key);\n          dest.right = newRight;\n          node2 = right;\n          dest = newRight;\n        }\n      } while (right != null);\n    }\n    const result = new SplayTreeSetNode(node.key);\n    copyChildren(node, result);\n    return result;\n  }\n  toSet() {\n    return this.clone();\n  }\n  entries() {\n    return new SplayTreeSetEntryIterableIterator(this.wrap());\n  }\n  keys() {\n    return this[Symbol.iterator]();\n  }\n  values() {\n    return this[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return new SplayTreeKeyIterableIterator(this.wrap());\n  }\n};\nvar SplayTreeIterableIterator = class SplayTreeIterableIterator {\n  constructor(tree) {\n    _defineProperty(this, \"tree\", void 0);\n    _defineProperty(this, \"path\", new Array());\n    _defineProperty(this, \"modificationCount\", null);\n    _defineProperty(this, \"splayCount\", void 0);\n    this.tree = tree;\n    this.splayCount = tree.getSplayCount();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    if (this.moveNext()) return {\n      done: false,\n      value: this.current()\n    };\n    return {\n      done: true,\n      value: null\n    };\n  }\n  current() {\n    if (!this.path.length) return null;\n    const node = this.path[this.path.length - 1];\n    return this.getValue(node);\n  }\n  rebuildPath(key) {\n    this.path.splice(0, this.path.length);\n    this.tree.splay(key);\n    this.path.push(this.tree.getRoot());\n    this.splayCount = this.tree.getSplayCount();\n  }\n  findLeftMostDescendent(node) {\n    while (node != null) {\n      this.path.push(node);\n      node = node.left;\n    }\n  }\n  moveNext() {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      if (this.modificationCount == null) {\n        this.modificationCount = this.tree.getModificationCount();\n        let node2 = this.tree.getRoot();\n        while (node2 != null) {\n          this.path.push(node2);\n          node2 = node2.left;\n        }\n        return this.path.length > 0;\n      }\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (!this.path.length) return false;\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    let node = this.path[this.path.length - 1];\n    let next = node.right;\n    if (next != null) {\n      while (next != null) {\n        this.path.push(next);\n        next = next.left;\n      }\n      return true;\n    }\n    this.path.pop();\n    while (this.path.length && this.path[this.path.length - 1].right === node) {\n      node = this.path.pop();\n    }\n    return this.path.length > 0;\n  }\n};\nvar SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return node.key;\n  }\n};\nvar SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {\n  getValue(node) {\n    return [node.key, node.key];\n  }\n};\nvar SplayTreeValueIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return node.value;\n  }\n};\nvar SplayTreeMapEntryIterableIterator = class extends SplayTreeIterableIterator {\n  constructor(map) {\n    super(map);\n  }\n  getValue(node) {\n    return [node.key, node.value];\n  }\n  replaceValue(value) {\n    if (this.modificationCount != this.tree.getModificationCount()) {\n      throw \"Concurrent modification during iteration.\";\n    }\n    if (this.splayCount != this.tree.getSplayCount()) {\n      this.rebuildPath(this.path[this.path.length - 1].key);\n    }\n    const last = this.path.pop();\n    const newLast = last.replaceValue(value);\n    if (!this.path.length) {\n      this.tree.setRoot(newLast);\n    } else {\n      const parent = this.path[this.path.length - 1];\n      if (last === parent.left) {\n        parent.left = newLast;\n      } else {\n        parent.right = newLast;\n      }\n    }\n    this.path.push(newLast);\n    const count = this.tree.getSplayCount() + 1;\n    this.tree.setSplayCount(count);\n    this.splayCount = count;\n  }\n};\nexport { SplayTreeMap, SplayTreeSet };","map":{"version":3,"names":["SplayTreeNode","constructor","key","_defineProperty","SplayTreeSetNode","SplayTreeMapNode","_SplayTreeMapNode","value","replaceValue","node","left","right","SplayTree","splay","root","compare","newTreeRight","newTreeLeft","current","comp","currentLeft","currentRight","splayCount","splayMin","nextLeft","splayMax","nextRight","_delete","result","size","modificationCount","addNewRoot","_first","_last","clear","has","validKey","defaultCompare","a","b","wrap","getRoot","setRoot","getSize","getModificationCount","getSplayCount","setSplayCount","count","SplayTreeMap","isValidKey","Symbol","toStringTag","delete","forEach","f","nodes","SplayTreeMapEntryIterableIterator","next","done","get","hasValue","initialSplayCount","visit","set","setAll","other","setIfAbsent","ifAbsent","isEmpty","isNotEmpty","firstKey","lastKey","lastKeyBefore","nodeRight","firstKeyAfter","nodeLeft","update","newValue","updateAll","iterator","keys","SplayTreeKeyIterableIterator","values","SplayTreeValueIterableIterator","entries","SplayTreeSet","_SplayTreeSet","v","element","deleteAll","elements","add","addAndReturn","addAll","single","first","last","lastBefore","firstAfter","retainAll","retainSet","object","lookup","intersection","difference","union","u","clone","copyNode","copyChildren","node2","dest","newLeft","newRight","toSet","SplayTreeSetEntryIterableIterator","SplayTreeIterableIterator","tree","Array","moveNext","path","length","getValue","rebuildPath","splice","push","findLeftMostDescendent","pop","map","newLast","parent"],"sources":["C:\\Users\\Nicholas Pollett\\Documents\\GitHub\\CollisionCalculator\\calculator-website\\node_modules\\splaytree-ts\\src\\index.ts"],"sourcesContent":["type Comparator<T> = (a: T, b: T) => number;\ntype Predicate<T> = (value: T) => boolean;\n\nclass SplayTreeNode<K, Node extends SplayTreeNode<K, Node>> {\n    readonly key: K;\n\n    left: Node | null = null;\n    right: Node | null = null;\n\n    constructor(key: K) {\n        this.key = key;\n    }\n}\n\nclass SplayTreeSetNode<K> extends SplayTreeNode<K, SplayTreeSetNode<K>> {\n    constructor(key: K) {\n        super(key);\n    }\n}\n\nclass SplayTreeMapNode<K, V> extends SplayTreeNode<K, SplayTreeMapNode<K, V>> {\n    readonly value: V;\n\n    constructor(key: K, value: V) {\n        super(key);\n        this.value = value;\n    }\n\n    replaceValue(value: V) {\n        const node = new SplayTreeMapNode(this.key, value);\n        node.left = this.left;\n        node.right = this.right;\n        return node;\n    }\n}\n\nabstract class SplayTree<K, Node extends SplayTreeNode<K, Node>> {\n    protected abstract root: Node | null;\n\n    public size = 0;\n\n    protected modificationCount = 0;\n\n    protected splayCount = 0;\n\n    protected abstract compare: Comparator<K>;\n\n    protected abstract validKey: Predicate<unknown>;\n\n    protected splay(key: K) {\n        const root = this.root;\n        if (root == null) {\n            this.compare(key, key);\n            return -1;\n        }\n\n        let right: Node | null = null;\n        let newTreeRight: Node | null = null;\n        let left: Node | null = null;\n        let newTreeLeft: Node | null = null;\n        let current = root;\n        const compare = this.compare;\n        let comp: number;\n        while (true) {\n            comp = compare(current.key, key);\n            if (comp > 0) {\n                let currentLeft = current.left;\n                if (currentLeft == null) break;\n                comp = compare(currentLeft.key, key);\n                if (comp > 0) {\n                    current.left = currentLeft.right;\n                    currentLeft.right = current;\n                    current = currentLeft;\n                    currentLeft = current.left;\n                    if (currentLeft == null) break;\n                }\n                if (right == null) {\n                    newTreeRight = current;\n                } else {\n                    right.left = current;\n                }\n                right = current;\n                current = currentLeft;\n            } else if (comp < 0) {\n                let currentRight = current.right;\n                if (currentRight == null) break;\n                comp = compare(currentRight.key, key);\n                if (comp < 0) {\n                    current.right = currentRight.left;\n                    currentRight.left = current;\n                    current = currentRight;\n                    currentRight = current.right;\n                    if (currentRight == null) break;\n                }\n                if (left == null) {\n                    newTreeLeft = current;\n                } else {\n                    left.right = current;\n                }\n                left = current;\n                current = currentRight;\n            } else {\n                break;\n            }\n        }\n        if (left != null) {\n            left.right = current.left;\n            current.left = newTreeLeft;\n        }\n        if (right != null) {\n            right.left = current.right;\n            current.right = newTreeRight;\n        }\n        if (this.root !== current) {\n            this.root = current;\n            this.splayCount++;\n        }\n        return comp;\n    }\n\n    protected splayMin(node: Node) {\n        let current = node;\n        let nextLeft = current.left;\n        while (nextLeft != null) {\n            const left = nextLeft;\n            current.left = left.right;\n            left.right = current;\n            current = left;\n            nextLeft = current.left;\n        }\n        return current;\n    }\n\n    protected splayMax(node: Node) {\n        let current = node;\n        let nextRight = current.right;\n        while (nextRight != null) {\n            const right = nextRight;\n            current.right = right.left;\n            right.left = current;\n            current = right;\n            nextRight = current.right;\n        }\n        return current;\n    }\n\n    protected _delete(key: K) {\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp != 0) return null;\n        let root = this.root;\n        const result = root;\n        const left = root.left;\n        this.size--;\n        if (left == null) {\n            this.root = root.right;\n        } else {\n            const right = root.right;\n            root = this.splayMax(left);\n\n            root.right = right;\n            this.root = root;\n        }\n        this.modificationCount++;\n        return result;\n    }\n\n    protected addNewRoot(node: Node, comp: number) {\n        this.size++;\n        this.modificationCount++;\n        const root = this.root;\n        if (root == null) {\n            this.root = node;\n            return;\n        }\n        if (comp < 0) {\n            node.left = root;\n            node.right = root.right;\n            root.right = null;\n        } else {\n            node.right = root;\n            node.left = root.left;\n            root.left = null;\n        }\n        this.root = node;\n    }\n\n    protected _first() {\n        const root = this.root;\n        if (root == null) return null;\n        this.root = this.splayMin(root);\n        return this.root;\n    }\n\n    protected _last() {\n        const root = this.root;\n        if (root == null) return null;\n        this.root = this.splayMax(root);\n        return this.root;\n    }\n\n    public clear() {\n        this.root = null;\n        this.size = 0;\n        this.modificationCount++;\n    }\n\n    public has(key: unknown) {\n        return this.validKey(key) && this.splay(key as K) == 0;\n    }\n\n    protected defaultCompare(): Comparator<K> {\n        return (a: K, b: K) => a < b ? -1 : a > b ? 1 : 0;\n    }\n\n    protected wrap(): SplayTreeWrapper<K, Node> {\n        return {\n            getRoot: () => { return this.root },\n            setRoot: (root) => { this.root = root },\n            getSize: () => { return this.size },\n            getModificationCount: () => { return this.modificationCount },\n            getSplayCount: () => { return this.splayCount },\n            setSplayCount: (count) => { this.splayCount = count },\n            splay: (key) => { return this.splay(key) },\n            has: (key) => { return this.has(key) },\n        };\n    }\n}\n\nexport class SplayTreeMap<K, V> extends SplayTree<K, SplayTreeMapNode<K, V>> implements Iterable<[K, V]>, Map<K, V> {\n    protected root: SplayTreeMapNode<K, V> | null = null;\n\n    protected compare: Comparator<K>;\n    protected validKey: Predicate<unknown>;\n\n    constructor(compare?: Comparator<K>, isValidKey?: Predicate<unknown>) {\n        super();\n        this.compare = compare ?? this.defaultCompare();\n        this.validKey = isValidKey ?? ((a: unknown) => a != null && a != undefined);\n    }\n\n    delete(key: unknown) {\n        if (!this.validKey(key)) return false;\n        return this._delete(key as K) != null;\n    }\n\n    forEach(f: (value: V, key: K, map: Map<K, V>) => void) {\n        const nodes: Iterator<[K, V]> = new SplayTreeMapEntryIterableIterator<K, V>(this.wrap());\n        let result: IteratorResult<[K, V]>;\n        while (result = nodes.next(), !result.done) {\n            f(result.value[1], result.value[0], this);\n        }\n    }\n\n    get(key: unknown): V | undefined {\n        if (!this.validKey(key)) return undefined;\n        if (this.root != null) {\n            const comp = this.splay(key as K);\n            if (comp == 0) {\n                return this.root!.value;\n            }\n        }\n        return undefined;\n    }\n\n    hasValue(value: unknown) {\n        const initialSplayCount = this.splayCount;\n        const visit = (node: SplayTreeMapNode<K, V> | null) => {\n            while (node != null) {\n                if (node.value == value) return true;\n                if (initialSplayCount != this.splayCount) {\n                    throw \"Concurrent modification during iteration.\";\n                }\n                if (node.right != null && visit(node.right)) {\n                    return true;\n                }\n                node = node.left;\n            }\n            return false;\n        }\n\n        return visit(this.root);\n    }\n\n    set(key: K, value: V) {\n        const comp = this.splay(key);\n        if (comp == 0) {\n            this.root = this.root!.replaceValue(value);\n            this.splayCount += 1;\n            return this;\n        }\n        this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n        return this;\n    }\n\n    setAll(other: Map<K, V>) {\n        other.forEach((value: V, key: K) => {\n            this.set(key, value);\n        });\n    }\n\n    setIfAbsent(key: K, ifAbsent: () => V) {\n        let comp = this.splay(key);\n        if (comp == 0) {\n            return this.root!.value;\n        }\n        const modificationCount = this.modificationCount;\n        const splayCount = this.splayCount;\n        const value = ifAbsent();\n        if (modificationCount != this.modificationCount) {\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (splayCount != this.splayCount) {\n            comp = this.splay(key);\n        }\n        this.addNewRoot(new SplayTreeMapNode(key, value), comp);\n        return value;\n    }\n\n    isEmpty() {\n        return this.root == null;\n    }\n\n    isNotEmpty() {\n        return !this.isEmpty();\n    }\n\n    firstKey() {\n        if (this.root == null) return null;\n        return this._first()!.key;\n    }\n\n    lastKey() {\n        if (this.root == null) return null;\n        return this._last()!.key;\n    }\n\n    lastKeyBefore(key: K) {\n        if (key == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp < 0) return this.root!.key;\n        let node: SplayTreeMapNode<K, V> | null = this.root!.left;\n        if (node == null) return null;\n        let nodeRight = node.right;\n        while (nodeRight != null) {\n            node = nodeRight;\n            nodeRight = node.right;\n        }\n        return node!.key;\n    }\n\n    firstKeyAfter(key: K) {\n        if (key == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(key);\n        if (comp > 0) return this.root!.key;\n        let node: SplayTreeMapNode<K, V> | null = this.root!.right;\n        if (node == null) return null;\n        let nodeLeft = node.left;\n        while (nodeLeft != null) {\n            node = nodeLeft;\n            nodeLeft = node.left;\n        }\n        return node!.key;\n    }\n\n    update(key: K, update: (value: V) => V, ifAbsent?: () => V) {\n        let comp = this.splay(key);\n        if (comp == 0) {\n            const modificationCount = this.modificationCount;\n            const splayCount = this.splayCount;\n            const newValue = update(this.root!.value);\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (splayCount != this.splayCount) {\n                this.splay(key);\n            }\n            this.root = this.root!.replaceValue(newValue);\n            this.splayCount += 1;\n            return newValue;\n        }\n        if (ifAbsent != null) {\n            const modificationCount = this.modificationCount;\n            const splayCount = this.splayCount;\n            const newValue = ifAbsent();\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (splayCount != this.splayCount) {\n                comp = this.splay(key);\n            }\n            this.addNewRoot(new SplayTreeMapNode(key, newValue), comp);\n            return newValue;\n        }\n        throw \"Invalid argument (key): Key not in map.\"\n    }\n\n    updateAll(update: (key: K, value: V) => V) {\n        const root = this.root;\n        if (root == null) return;\n        const iterator = new SplayTreeMapEntryIterableIterator(this.wrap());\n        let node: IteratorResult<[K, V]>;\n        while (node = iterator.next(), !node.done) {\n            const newValue = update(...node.value);\n            iterator.replaceValue(newValue);\n        }\n    }\n\n    keys(): IterableIterator<K> {\n        return new SplayTreeKeyIterableIterator<K, SplayTreeMapNode<K, V>>(this.wrap());\n    }\n\n    values(): IterableIterator<V> {\n        return new SplayTreeValueIterableIterator<K, V>(this.wrap());\n    }\n\n    entries(): IterableIterator<[K, V]> {\n        return this[Symbol.iterator]();\n    }\n\n    [Symbol.iterator](): IterableIterator<[K, V]> {\n        return new SplayTreeMapEntryIterableIterator<K, V>(this.wrap());\n    }\n\n    [Symbol.toStringTag] = '[object Map]'\n}\n\nexport class SplayTreeSet<E> extends SplayTree<E, SplayTreeSetNode<E>> implements Iterable<E>, Set<E> {\n    protected root: SplayTreeSetNode<E> | null = null;\n\n    protected compare: Comparator<E>;\n    protected validKey: Predicate<unknown>;\n\n    constructor(compare?: Comparator<E>, isValidKey?: Predicate<unknown>) {\n        super();\n        this.compare = compare ?? this.defaultCompare();\n        this.validKey = isValidKey ?? ((v: unknown) => v != null && v != undefined );\n    }\n\n    delete(element: unknown) {\n        if (!this.validKey(element)) return false;\n        return this._delete(element as E) != null;\n    }\n\n    deleteAll(elements: Iterable<unknown>) {\n        for (const element of elements) {\n            this.delete(element);\n        }\n    }\n\n    forEach(f: (element: E, element2: E, set: Set<E>) => void) {\n        const nodes: Iterator<E> = this[Symbol.iterator]();\n        let result: IteratorResult<E>;\n        while (result = nodes.next(), !result.done) {\n            f(result.value, result.value, this);\n        }\n    }\n\n    add(element: E) {\n        const compare = this.splay(element);\n        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n        return this;\n    }\n\n    addAndReturn(element: E) {\n        const compare = this.splay(element);\n        if (compare != 0) this.addNewRoot(new SplayTreeSetNode(element), compare);\n        return this.root!.key;\n    }\n\n    addAll(elements: Iterable<E>) {\n        for (const element of elements) {\n            this.add(element);\n        }\n    }\n\n    isEmpty() {\n        return this.root == null;\n    }\n\n    isNotEmpty() {\n        return this.root != null;\n    }\n\n    single() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        if (this.size > 1) throw \"Bad state: Too many element\";\n        return this.root!.key;\n    }\n\n    first() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        return this._first()!.key;\n    }\n\n    last() {\n        if (this.size == 0) throw \"Bad state: No element\";\n        return this._last()!.key;\n    }\n\n    lastBefore(element: E) {\n        if (element == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(element);\n        if (comp < 0) return this.root!.key;\n        let node: SplayTreeSetNode<E> | null = this.root!.left;\n        if (node == null) return null;\n        let nodeRight = node.right;\n        while (nodeRight != null) {\n            node = nodeRight;\n            nodeRight = node.right;\n        }\n        return node!.key;\n    }\n\n    firstAfter(element: E) {\n        if (element == null) throw \"Invalid arguments(s)\";\n        if (this.root == null) return null;\n        const comp = this.splay(element);\n        if (comp > 0) return this.root!.key;\n        let node: SplayTreeSetNode<E> | null = this.root!.right;\n        if (node == null) return null;\n        let nodeLeft = node.left;\n        while (nodeLeft != null) {\n            node = nodeLeft;\n            nodeLeft = node.left;\n        }\n        return node!.key;\n    }\n\n    retainAll(elements: Iterable<unknown>) {\n        const retainSet = new SplayTreeSet<E>(this.compare, this.validKey);\n        const modificationCount = this.modificationCount;\n        for (const object of elements) {\n            if (modificationCount != this.modificationCount) {\n                throw \"Concurrent modification during iteration.\";\n            }\n            if (this.validKey(object) && this.splay(object as E) == 0) {\n                retainSet.add(this.root!.key);\n            }\n        }\n        if (retainSet.size != this.size) {\n            this.root = retainSet.root;\n            this.size = retainSet.size;\n            this.modificationCount++;\n        }\n    }\n\n    lookup(object: unknown): E | null {\n        if (!this.validKey(object)) return null;\n        const comp = this.splay(object as E);\n        if (comp != 0) return null;\n        return this.root!.key;\n    }\n\n    intersection(other: Set<unknown>): Set<E> {\n        const result = new SplayTreeSet<E>(this.compare, this.validKey);\n        for (const element of this) {\n            if (other.has(element)) result.add(element);\n        }\n        return result;\n    }\n\n    difference(other: Set<unknown>): Set<E> {\n        const result = new SplayTreeSet<E>(this.compare, this.validKey);\n        for (const element of this) {\n            if (!other.has(element)) result.add(element);\n        }\n        return result;\n    }\n\n    union(other: Set<E>): Set<E> {\n        const u = this.clone();\n        u.addAll(other);\n        return u;\n    }\n\n    protected clone() {\n        const set = new SplayTreeSet<E>(this.compare, this.validKey);\n        set.size = this.size;\n        set.root = this.copyNode<SplayTreeSetNode<E>>(this.root);\n        return set;\n    }\n\n    protected copyNode<Node extends SplayTreeNode<E, Node>>(node: Node | null) {\n        if (node == null) return null;\n        function copyChildren(node: Node, dest: SplayTreeSetNode<E>) {\n            let left: Node | null;\n            let right: Node | null;\n            do {\n                left = node.left;\n                right = node.right;\n                if (left != null) {\n                    const newLeft = new SplayTreeSetNode<E>(left.key);\n                    dest.left = newLeft;\n                    copyChildren(left, newLeft);\n                }\n                if (right != null) {\n                    const newRight = new SplayTreeSetNode<E>(right.key);\n                    dest.right = newRight;\n                    node = right;\n                    dest = newRight;\n                }\n            } while (right != null);\n        }\n\n        const result = new SplayTreeSetNode<E>(node.key);\n        copyChildren(node, result);\n        return result;\n    }\n\n    toSet(): Set<E> {\n        return this.clone();\n    }\n\n    entries(): IterableIterator<[E, E]> {\n        return new SplayTreeSetEntryIterableIterator<E, SplayTreeSetNode<E>>(this.wrap());\n    }\n\n    keys(): IterableIterator<E> {\n        return this[Symbol.iterator]();\n    }\n    \n    values(): IterableIterator<E> {\n        return this[Symbol.iterator]();\n    }\n\n    [Symbol.iterator](): IterableIterator<E> {\n        return new SplayTreeKeyIterableIterator<E, SplayTreeSetNode<E>>(this.wrap());\n    }\n\n    [Symbol.toStringTag] = '[object Set]'\n}\n\ninterface SplayTreeWrapper<K, Node extends SplayTreeNode<K, Node>> {\n    getRoot: () => Node | null;\n    setRoot: (root: Node | null) => void;\n    getSize: () => number;\n    getModificationCount: () => number;\n    getSplayCount: () => number;\n    setSplayCount: (count: number) => void;\n    splay: (key: K) => number;\n    has: (key: unknown) => boolean;\n}\n\ntype SplayTreeMapWrapper<K, V> = SplayTreeWrapper<K, SplayTreeMapNode<K, V>>;\n\nabstract class SplayTreeIterableIterator<K, Node extends SplayTreeNode<K, Node>, T> implements IterableIterator<T> {\n    protected readonly tree: SplayTreeWrapper<K, Node>;\n\n    protected readonly path = new Array<Node>();\n\n    protected modificationCount: number | null = null;\n\n    protected splayCount: number;\n\n    constructor(tree: SplayTreeWrapper<K, Node>) {\n        this.tree = tree;\n        this.splayCount = tree.getSplayCount();\n    }\n\n    [Symbol.iterator](): IterableIterator<T> {\n        return this;\n    }\n\n    next(): IteratorResult<T, null> {\n        if (this.moveNext()) return { done: false, value: this.current()! }\n        return { done: true, value: null }\n    }\n\n    protected current() {\n        if (!this.path.length) return null;\n        const node = this.path[this.path.length - 1];\n        return this.getValue(node);\n    }\n\n    protected rebuildPath(key: K) {\n        this.path.splice(0, this.path.length)\n        this.tree.splay(key);\n        this.path.push(this.tree.getRoot()!);\n        this.splayCount = this.tree.getSplayCount();\n    }\n\n    protected findLeftMostDescendent(node: Node | null) {\n        while (node != null) {\n            this.path.push(node);\n            node = node.left;\n        }\n    }\n\n    protected moveNext() {\n        if (this.modificationCount != this.tree.getModificationCount()) {\n            if (this.modificationCount == null) {\n                this.modificationCount = this.tree.getModificationCount();\n                let node = this.tree.getRoot();\n                while (node != null) {\n                    this.path.push(node);\n                    node = node.left;\n                }\n                return this.path.length > 0;\n            }\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (!this.path.length) return false;\n        if (this.splayCount != this.tree.getSplayCount()) {\n            this.rebuildPath(this.path[this.path.length - 1].key);\n        }\n        let node = this.path[this.path.length - 1];\n        let next = node.right;\n        if (next != null) {\n            while (next != null) {\n                this.path.push(next);\n                next = next.left;\n            }\n            return true;\n        }\n        this.path.pop();\n        while (this.path.length && this.path[this.path.length - 1].right === node) {\n            node = this.path.pop()!;\n        }\n        return this.path.length > 0;\n    }\n\n    protected abstract getValue(node: Node): T\n}\n\nclass SplayTreeKeyIterableIterator<K, Node extends SplayTreeNode<K, Node>> extends SplayTreeIterableIterator<K, Node, K> {\n\n    protected getValue(node: Node) {\n        return node.key;\n    }\n}\n\nclass SplayTreeSetEntryIterableIterator<K, Node extends SplayTreeNode<K, Node>> extends SplayTreeIterableIterator<K, Node, [K, K]> {\n\n    protected getValue(node: Node): [K, K] {\n        return [node.key, node.key];\n    }\n}\n\nclass SplayTreeValueIterableIterator<K, V> extends SplayTreeIterableIterator<K, SplayTreeMapNode<K, V>, V> {\n\n    constructor(map: SplayTreeMapWrapper<K, V>) {\n        super(map);\n    }\n\n    protected getValue(node: SplayTreeMapNode<K, V>) {\n        return node.value;\n    }\n}\n\nclass SplayTreeMapEntryIterableIterator<K, V> extends SplayTreeIterableIterator<K, SplayTreeMapNode<K, V>, [K, V]> {\n\n    constructor(map: SplayTreeMapWrapper<K, V>) {\n        super(map);\n    }\n\n    protected getValue(node: SplayTreeMapNode<K, V>): [K, V] {\n        return [node.key, node.value];\n    }\n\n    replaceValue(value: V) {\n        if (this.modificationCount != this.tree.getModificationCount()) {\n            throw \"Concurrent modification during iteration.\";\n        }\n        if (this.splayCount != this.tree.getSplayCount()) {\n            this.rebuildPath(this.path[this.path.length - 1].key);\n        }\n        const last = this.path.pop()!;\n        const newLast = last.replaceValue(value);\n        if (!this.path.length) {\n            this.tree.setRoot(newLast);\n        } else {\n            const parent = this.path[this.path.length - 1];\n            if (last === parent.left) {\n                parent.left = newLast;\n            } else {\n                parent.right = newLast;\n            }\n        }\n        this.path.push(newLast);\n        const count = this.tree.getSplayCount() + 1;\n        this.tree.setSplayCount(count);\n        this.splayCount = count;\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}